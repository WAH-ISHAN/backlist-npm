// Auto-generated by create-backlist
package <%= group %>.<%= projectName %>.service;

import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

import <%= group %>.<%= projectName %>.repository.<%= modelName %>Repository;
import <%= group %>.<%= projectName %>.model.<%= modelName %>;

@Service
public class <%= modelName %>Service {

  private final <%= modelName %>Repository repo;

  public <%= modelName %>Service(<%= modelName %>Repository repo) {
    this.repo = repo;
  }

  public List<<%= modelName %>> findAll() {
    return repo.findAll();
  }

  public Optional<<%= modelName %>> findById(Long id) {
    return repo.findById(id);
  }

  public <%= modelName %> create(<%= modelName %> m) {
    // Ensure id is not forced by client
    m.setId(null);
    return repo.save(m);
  }

  public Optional<<%= modelName %>> update(Long id, <%= modelName %> m) {
    return repo.findById(id).map(existing -> {
<% model.fields.forEach(f => { 
  const cap = f.name.charAt(0).toUpperCase() + f.name.slice(1);
-%>
      // Update <%= f.name %>
      existing.set<%= cap %>(m.get<%= cap %>());
<% }) -%>
      return repo.save(existing);
    });
  }

  /**
   * Partial update: only set non-null values.
   * Useful if your frontend sends partial payloads.
   */
  public Optional<<%= modelName %>> patch(Long id, <%= modelName %> m) {
    return repo.findById(id).map(existing -> {
<% model.fields.forEach(f => { 
  const cap = f.name.charAt(0).toUpperCase() + f.name.slice(1);
-%>
      if (m.get<%= cap %>() != null) {
        existing.set<%= cap %>(m.get<%= cap %>());
      }
<% }) -%>
      return repo.save(existing);
    });
  }

  public boolean delete(Long id) {
    if (!repo.existsById(id)) return false;
    repo.deleteById(id);
    return true;
  }
}