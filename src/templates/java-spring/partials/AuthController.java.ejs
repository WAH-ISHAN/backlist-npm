// Auto-generated by create-backlist
package <%= group %>.<%= projectName %>.controller;

import <%= group %>.<%= projectName %>.model.User;
import <%= group %>.<%= projectName %>.repository.UserRepository;
import <%= group %>.<%= projectName %>.security.JwtService;

import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*")
public class AuthController {

  private final UserRepository repo;
  private final PasswordEncoder encoder;
  private final JwtService jwt;

  public AuthController(UserRepository repo, PasswordEncoder encoder, JwtService jwt) {
    this.repo = repo;
    this.encoder = encoder;
    this.jwt = jwt;
  }

  public record RegisterRequest(String name, String email, String password) {}
  public record LoginRequest(String email, String password) {}
  public record TokenResponse(String token) {}
  public record ErrorResponse(String message) {}

  @PostMapping("/register")
  public ResponseEntity<?> register(@RequestBody RegisterRequest req) {
    if (req == null || isBlank(req.email()) || isBlank(req.password()) || isBlank(req.name())) {
      return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse("name, email, password are required"));
    }

    if (repo.findByEmail(req.email()).isPresent()) {
      // better than 400: conflict
      return ResponseEntity.status(HttpStatus.CONFLICT).body(new ErrorResponse("User already exists"));
    }

    User user = new User();
    user.setName(req.name());
    user.setEmail(req.email());
    user.setPassword(encoder.encode(req.password()));

    repo.save(user);

    String token = jwt.generateToken(user.getEmail());
    return ResponseEntity.status(HttpStatus.CREATED).body(new TokenResponse(token));
  }

  @PostMapping("/login")
  public ResponseEntity<?> login(@RequestBody LoginRequest req) {
    if (req == null || isBlank(req.email()) || isBlank(req.password())) {
      return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse("email and password are required"));
    }

    Optional<User> current = repo.findByEmail(req.email());
    if (current.isEmpty()) {
      // better than 400: unauthorized
      return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse("Invalid credentials"));
    }

    if (!encoder.matches(req.password(), current.get().getPassword())) {
      return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse("Invalid credentials"));
    }

    String token = jwt.generateToken(current.get().getEmail());
    return ResponseEntity.ok(new TokenResponse(token));
  }

  private boolean isBlank(String s) {
    return s == null || s.trim().isEmpty();
  }
}