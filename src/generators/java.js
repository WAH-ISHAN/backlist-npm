const chalk = require("chalk");
const fs = require("fs-extra");
const path = require("path");
const axios = require("axios");
const unzipper = require("unzipper");

const { analyzeFrontend } = require("../analyzer");
const { renderAndWrite, getTemplatePath } = require("./template");

function sanitizeArtifactId(name) {
  return String(name || "backend")
    .toLowerCase()
    .replace(/[^a-z0-9\-]/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-+|-+$/g, "");
}

async function downloadInitializrZip({ groupId, artifactId, name, bootVersion, dependencies }) {
  const params = new URLSearchParams({
    type: "maven-project",
    language: "java",
    groupId,
    artifactId,
    name,
    packageName: `${groupId}.${artifactId.replace(/-/g, "")}`,
    dependencies: dependencies.join(","),
  });

  if (bootVersion) params.set("bootVersion", bootVersion);

  const url = `https://start.spring.io/starter.zip?${params.toString()}`;

  const res = await axios.get(url, {
    responseType: "stream",
    headers: { Accept: "application/zip" },
  });

  return res;
}

async function extractZipStream(stream, dest) {
  await new Promise((resolve, reject) => {
    const out = stream.pipe(unzipper.Extract({ path: dest }));
    out.on("close", resolve);
    out.on("finish", resolve);
    out.on("error", reject);
  });
}

async function appendApplicationProperties(projectDir, artifactId) {
  try {
    const propsPath = path.join(projectDir, "src", "main", "resources", "application.properties");
    const dbProps = [
      "",
      "",
      "# --- Auto-generated by create-backlist ---",
      `spring.datasource.url=jdbc:postgresql://localhost:5432/${artifactId}`,
      "spring.datasource.username=postgres",
      "spring.datasource.password=password",
      "spring.jpa.hibernate.ddl-auto=update",
      "spring.jpa.show-sql=true",
    ].join("\n");

    await fs.appendFile(propsPath, dbProps);
  } catch {
    console.log(chalk.yellow("  -> Could not update application.properties (continuing)."));
  }
}

function buildModelsFromEndpoints(endpoints) {
  // Create models even when schemaFields is null (GET-only APIs).
  const modelsToGenerate = new Map();

  (Array.isArray(endpoints) ? endpoints : []).forEach((ep) => {
    if (!ep || !ep.controllerName || ep.controllerName === "Default") return;

    if (!modelsToGenerate.has(ep.controllerName)) {
      modelsToGenerate.set(ep.controllerName, {
        name: ep.controllerName,
        fields: [],
        endpoints: [],
      });
    }

    const m = modelsToGenerate.get(ep.controllerName);

    m.endpoints.push({
      method: ep.method,
      route: ep.route || ep.path,
      actionName: ep.actionName,
    });

    if (ep.schemaFields) {
      for (const [key, type] of Object.entries(ep.schemaFields)) {
        if (!m.fields.find((f) => f.name === key)) {
          m.fields.push({ name: key, type });
        }
      }
    }
  });

  return modelsToGenerate;
}

async function generateJavaProject(options) {
  const { projectDir, projectName, frontendSrcDir } = options;

  const groupId = "com.backlist.generated";
  const artifactId = sanitizeArtifactId(projectName || "backend");
  const name = projectName || "backend";

  try {
    console.log(chalk.blue("  -> Contacting Spring Initializr to download a base Spring Boot project..."));

    const deps = ["web", "data-jpa", "lombok", "postgresql"];
    let response;

    try {
      response = await downloadInitializrZip({
        groupId,
        artifactId,
        name,
        bootVersion: "3.3.4",
        dependencies: deps,
      });
    } catch {
      console.log(chalk.yellow("    -> Initial attempt failed. Retrying with default Boot version..."));
      try {
        response = await downloadInitializrZip({
          groupId,
          artifactId,
          name,
          bootVersion: "",
          dependencies: deps,
        });
      } catch {
        console.log(chalk.yellow("    -> Second attempt failed. Retrying with minimal dependencies..."));
        const fallbackDeps = ["web", "data-jpa", "lombok"];
        response = await downloadInitializrZip({
          groupId,
          artifactId,
          name,
          bootVersion: "",
          dependencies: fallbackDeps,
        });
      }
    }

    console.log(chalk.blue("  -> Unzipping the Spring Boot project..."));
    await fs.ensureDir(projectDir);
    await extractZipStream(response.data, projectDir);

    console.log(chalk.blue("  -> Analyzing frontend for API endpoints..."));
    const endpoints = await analyzeFrontend(frontendSrcDir);

    if (!Array.isArray(endpoints) || endpoints.length === 0) {
      console.log(chalk.yellow("  -> No endpoints found. Only base Spring project created."));
    } else {
      console.log(chalk.green(`  -> Found ${endpoints.length} endpoints.`));
    }

    const modelsToGenerate = buildModelsFromEndpoints(endpoints);

    // Spring Initializr extracts into projectDir directly. Java package folder:
    const javaSrcRoot = path.join(
      projectDir,
      "src",
      "main",
      "java",
      ...groupId.split("."),
      artifactId.replace(/-/g, "")
    );

    // Always ensure base package dirs exist
    await fs.ensureDir(javaSrcRoot);

    if (modelsToGenerate.size > 0) {
      console.log(chalk.blue("  -> Generating Java entities, repositories, and controllers..."));

      const entityDir = path.join(javaSrcRoot, "model");
      const repoDir = path.join(javaSrcRoot, "repository");
      const controllerDir = path.join(javaSrcRoot, "controller");

      await fs.ensureDir(entityDir);
      await fs.ensureDir(repoDir);
      await fs.ensureDir(controllerDir);

      for (const model of modelsToGenerate.values()) {
        await renderAndWrite(
          getTemplatePath("java-spring/partials/Entity.java.ejs"),
          path.join(entityDir, `${model.name}.java`),
          { projectName, groupId, artifactId, model }
        );

        await renderAndWrite(
          getTemplatePath("java-spring/partials/Repository.java.ejs"),
          path.join(repoDir, `${model.name}Repository.java`),
          { projectName, groupId, artifactId, model }
        );

        await renderAndWrite(
          getTemplatePath("java-spring/partials/Controller.java.ejs"),
          path.join(controllerDir, `${model.name}Controller.java`),
          { projectName, groupId, artifactId, model }
        );
      }
    } else {
      console.log(chalk.yellow("  -> No models inferred (controllerName missing). Skipping entity/controller generation."));
    }

    await appendApplicationProperties(projectDir, artifactId);

    console.log(chalk.green("  -> Java (Spring Boot) backend generation is complete!"));
    console.log(chalk.yellow("\nNext steps:"));
    console.log(chalk.cyan(`  cd ${path.basename(projectDir)}`));
    console.log(chalk.cyan("  ./mvnw spring-boot:run   # or use your IDE to run the Application class"));
  } catch (error) {
    // Better Initializr error print
    if (error && error.response && error.response.status) {
      console.error(chalk.red(`  -> Initializr error status: ${error.response.status}`));

      try {
        if (error.response.data) {
          let text = "";
          for await (const chunk of error.response.data) text += chunk.toString();
          console.error(chalk.yellow("  -> Initializr response body:"), text);
        }
      } catch {
        // ignore
      }

      throw new Error(`Failed to download from Spring Initializr. Status: ${error.response.status}`);
    }

    throw error;
  }
}

module.exports = { generateJavaProject };